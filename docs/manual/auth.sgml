<sect>Authentication Configuration
<p>
The following sections in the config file can be used to configure authentication.

<sect1>Section &lsqb;Gatekeeper::Auth&rsqb;
<label id="gkauth">
<p>
The section defines the authentication mechanism / modules for the
<htmlurl url="https://www.gnugk.org/" name="GNU Gatekeeper">.
After defining which modules to use, you have to add the corresponding
config sections for each module.

<descrip>
<tag/Syntax:/
<tscreen><verb>
authrule=actions

 <authrule> := SimplePasswordAuth | AliasAuth | FileIPAuth | PrefixAuth | RadAuth | RadAliasAuth | SQLAuth | SQLAliasAuth | SQLPasswordAuth | H350PasswordAuth | LDAPPasswordAuth | LDAPAliasAuth | LuaAuth | LuaPasswordAuth | HttpPasswordAuth | GeoIPAUth | TwoAliasAuth | CapacityControl | ...
 <actions>  := <control>[;<ras>|<q931>,<ras>|<q931>,...]
 <control>  := optional | required | sufficient | alternative
 <ras>      := GRQ | RRQ | URQ | ARQ | BRQ | DRQ | LRQ | IRQ | RAI
 <q931>     := Setup | SetupUnreg | Connect | CallProceeding | Alerting | Information | ReleaseComplete | Facility | Progress | Empty | Status | StatusEnquiry | SetupAck | Notify    

</verb></tscreen>
</descrip>

A rule may result in one of three codes: ok, fail, next.
<itemize>
<item><tt/ok/ - The request is authenticated by this module.
<item><tt/fail/ - The authentication fails and should be rejected.
<item><tt/next/ - The rule cannot determine the request.
</itemize>
There are also three ways to control a rule:
<itemize>
<item><tt/optional/ - If the rule cannot determine the request or accepts it, it is passed to next rule. Otherwise processing stops and the request is rejected.
<item><tt/required/ - The requests should be authenticated by this module, or it would be rejected. The authenticated request would then be passed to next rule.
<item><tt/sufficient/ - If the request is authenticated, it is accepted, or it would be rejected. That is, the rule determines the fate of the request. No rule should be put after a sufficient rule, since it won't take effect.
<item><tt/alternative/ - similar to the <tt/sufficient/ rule, except that if the module cannot determine the result the request is passed to a next module.
</itemize>

Currently supported modules: (most only support a subset of the RAS or Q.931 actions)
<itemize>
<item><tt>SimplePasswordAuth/SQLPasswordAuth/H350PasswordAuth/LuaPasswordAuth/HttpPasswordAuth</tt>
<p>
These modules check the tokens or cryptoTokens fields of a RAS message.
The tokens should contain at least generalID and password.
For cryptoTokens, cryptoEPPwdHash tokens hashed by simple MD5 and
nestedcryptoToken tokens hashed by HMAC-SHA1-96
are supported. For tokens hashed by CAT (Cisco Access Token)
a clear text username/password are supported.
The ID and password are read from the <ref id="password" name="[SimplePasswordAuth]"> section,
or a SQL database for <tt/SimplePasswordAuth/ and <tt/SQLPasswordAuth/
modules.
With <ref id="luapasswordauth" name="LuaPasswordAuth"> you can use a Lua script to lookup the passwords and <ref id="httppasswordauth" name="HttpPasswordAuth"> lets you fetch passowrds from an HTTP server (eg. from a REST service).
<p>
For H.350.2 authentication (<tt/H350PasswordAuth/)
the <ref id="h350settings" name="[GkH350::Settings]"> connection information must be completed.
The <ref id="h350passwordauth" name="[H350PasswordAuth]"> section is optional.

<item><tt>AliasAuth/SQLAliasAuth</tt>
<p>
The module can only be used to authenticate RegistrationRequest (RRQ).
The IP of an endpoint with a given alias should match a specified pattern.
For <tt/AliasAuth/ the pattern is defined in the 
<ref id="rrqauth" name="[RasSrv::RRQAuth]"> section.
For <tt/SQLAliasAuth/, the pattern is retrieved from a SQL database as 
defined in the <ref id="sqlaliasauth" name="[SQLAliasAuth]"> section.

<item><tt>FileIPAuth</tt>
<p>
This module provides a simple way to restrict access to the gatekeeper
based on caller's IP or network.

<item><tt>PrefixAuth</tt>
<p>
The IP or aliases of a request with a given prefix must match a specified
pattern. See section <ref id="prefixauth" name="[PrefixAuth]"> for details.
The module can authorize
AdmissionRequest (ARQ), LocationRequest (LRQ), Setup and SetupUnreg.

<item><tt>RadAuth</tt>
<p>
Provides authentication based on H.235 username/password
security scheme. Authenticates RRQ, ARQ and Q.931 Setup through remote
RADIUS servers. It sends usernames and passwords
extracted from CAT (Cisco Access Tokens) tokens carried
inside RRQ, ARQ or Setup packets to the RADIUS servers. If your endpoints do not
support CATs or you do not need an authentication scheme based on
individually assigned usernames/password then this module would not be appropriate
(but you may check the <tt/RadAliasAuth/ module).
See section <ref id="radauth" name="[RadAuth]"> for details.

<item><tt>RadAliasAuth</tt>
<p>
Provides authentication based on endpoint aliases
and/or call signaling IP addresses with remote RADIUS servers.
It does not need any H.235 tokens inside RAS messages,
so it can be used on a wider range of systems as compared to <tt/RadAuth/.
RRQ, ARQ and Q.931 Setup messages can be authenticated using this module.
See section <ref id="radaliasauth" name="[RadAliasAuth]"> for details.

<item><tt>SQLAuth</tt>
<p>
A powerful module to authenticate and authorize RRQ, ARQ, LRQ and Setup
messages. It can perform checks based on various parameters such as 
caller's number, destination number, username and more. It also supports
enforcing call duration limit, number rewriting, call routing, alias
verification and assignment.
See section <ref id="sqlauth" name="[SQLAuth]"> for more details.

<item><tt>LDAPPasswordAuth</tt>
<p>
This module will lookup the called aliases in your LDAP schema searching
the H323ID and telephoneNumber attribute and checks if the password in the
H235Password attribute matches the H.235 crypto token.
<p>
The LDAP server is configured in the <ref id="ldapsettings" name="GkLDAP::Settings"> section
and the attribute matching is defined in the
<ref id="ldapattributes" name="GkLDAP::LDAPAttributeNames"> section.

<item><tt>LDAPAliasAuth</tt>
<p>
This module will lookup the called aliases in your LDAP schema searching
the H323ID and telephoneNumber attribute and checks if the IP matches the IPAddress attribute.
<p>
The LDAP server is configured in the <ref id="ldapsettings" name="GkLDAP::Settings"> section
and the attribute matching is defined in the
<ref id="ldapattributes" name="GkLDAP::LDAPAttributeNames"> section.

<item><tt>LuaAuth</tt>
<p>
This module utilizes user-defined LUA scripts to perform authentication.
The scripts are configured in the <ref id="luaauth" name="LuaAuth"> section.

<item><tt>GeoIPAuth</tt>
<p>
This module checks the which country the message comes from by looking at the IP.
The module is configured in the <ref id="geoipauth" name="GeoIPAuth"> section.

<item><tt>TwoAliasAuth</tt>
<p>
This module checks if the endpoint has 2 matching aliases.
This is a very weak authentication, only to be used when nothing else is possible.
The module is configured in the <ref id="twoaliasauth" name="TwoAliasAuth"> section.

The module can authorize RegistrationRequest (RRQ), Setup and SetupUnreg.

<item><tt>CapacityControl</tt>
<p>
A flexible module to control inbound call volume with the ability to configure
various conditions. IMPORTANT: It must be used in conjunction with the <tt/CapacityControl/
accounting module. See section <ref id="capctrl" name="[CapacityControl]"> for more details.
 
</itemize>

You can also configure a rule to check only for specific RAS messages.
The following example configures <tt/SimplePasswordAuth/ as an optional rule
to check RRQ and ARQ. If a RRQ is not checked (does not contain
tokens or cryptoTokens fields), it is checked by <tt/AliasAuth/.
The default is to check all supported requests.

<descrip>
<tag/Example 1:/
<tt/SimplePasswordAuth=alternative;RRQ,ARQ/<newline>
<tt/AliasAuth=sufficient;RRQ/<newline>
</descrip>

The example below authenticates all calls, checking signaling Setup
message details, using the RadAliasAuth module.

<descrip>
<tag/Example 2:/
<tt/RadAliasAuth=required;Setup/<newline>
<tt/default=allow/
</descrip>

This example checks endpoint registrations (RRQ) and call admissions (ARQ)
either by means of username/password (RadAuth) or alias/IP (RadAliasAuth).
Additionally, if the call is from an unregistered endpoint (and therefore
no RRQ or ARQ authentication has been performed), Setup message authentication
using RadAliasAuth takes place (SetupUnreg).

<descrip>
<tag/Example 3:/
<tt/RadAuth=alternative;RRQ,ARQ/<newline>
<tt/RadAliasAuth=alternative;RRQ,ARQ,SetupUnreg/<newline>
<tt/default=reject/
</descrip>

<sect1>Section &lsqb;FileIPAuth&rsqb;
<label id="fileipauth">
<p>
This section defines a list of IP addresses/networks which are allowed
to access gatekeeper resources. A list of allowed prefixes can be specified
together with an IP address. Supported Gatekeeper::Auth events are:
<tt/GRQ/, <tt/RRQ/, <tt/ARQ/, <tt/LRQ/, <tt/Setup/ and <tt/SetupUnreg/. Format
of a single entry is:
<p><tt/IP=[allow | reject | onlyTLS][;prefix[,prefix...]]/
<p>
where IP is a single IP address, a network address (in A.B.C.D/M.M.M.M or A.B.C.D/LENGTH format or IPv6 format) or a string <tt/'any'/ or <tt/'*'/ to match any address.
The access list can also be loaded from an external file using <tt/include/ directive. During authentication, network mask length defines a priority for each
entry, so rule 192.168.1.1=allow takes precedence over 192.168.1.0/24=reject.
<p>
<tt/'onlyTLS'/ is equivalent to <tt/'allow'/ if the call comes in via a
<ref id="tls" name="TLS"> secured connection and means <tt/'reject'/ for unencrypted calls.
<p>
In addition the to endpoint's IP, you can specify a list of prefixes that the endpoint may call.
The destination prefixes are only checked on ARQ and Setup messages.

<descrip><tag/Example #1:/
<tscreen><verb>
[Gatekeeper::Auth]
FileIPAuth=required;RRQ,ARQ,LRQ,Setup

[FileIPAuth]
192.168.1.240=reject
192.168.1.0/24=allow
192.168.2.0/255.255.255.0=allow;48,49,44
2a01:4f8:61:2243::2=allow
2a01:4f8:61:2243::10/128=allow
2a01:4f8:61:2243::/64=allow
any=reject
</verb></tscreen>
</descrip>

<descrip><tag/Example #2:/

Placing the list of IP rules into another file.

<tscreen><verb>
[Gatekeeper::Auth]
FileIPAuth=required;Setup

[FileIPAuth]
include=/etc/gnugk/accesslist.ini

(EOF)

Contents of /etc/gnugk/accesslist.ini:

[FileIPAuth]
192.168.1.1=allow
192.168.1.100=allow
any=reject
</verb></tscreen>
</descrip>

<descrip><tag/Example #3:/

Allow all connects from the local network, but require
TLS encryption and authentification for everything else.

<tscreen><verb>
[Gatekeeper::Auth]
FileIPAuth=required;Setup

[FileIPAuth]
192.168.1.0/24=allow
any=onlyTLS
</verb></tscreen>
</descrip>


<sect1>Section &lsqb;H235&rsqb;
<label id="h235">
<p>
This section contains setting that apply to all authentication policies using H.235.1 passwords.

When using H.235 authentication, it is very important that the gatekeeper and all endpoints have
the correct time configured (eg. using NTP).
If they vary by more than the defined grace period (see below), otherwise valid tokens will be rejected!

<itemize>
<item><tt/UseEndpointIdentifier=0/<newline>
Default: <tt/1/<newline>
<p>
Use the endpoint identifier as RemoteID.
When calling Innovaphone r6 endpoints, this must be off. With Innovaphone r11 it may be on.

<item><tt/RequireGeneralID=1/<newline>
Default: <tt/0/<newline>
<p>
The H.235v3 spec requires endpoints to send a GeneralID inside H.235.1 tokens.
Some endpoint vendors don't include the GeneralID, eg. AudioCodes and Innovaphone.

<item><tt/FullQ931Checking=1/<newline>
Default: <tt/0/<newline>
<p>
The H.235v3 spec mandates all Q,931 signaling messages (Setup, Alerting, Connect etc.)
be secured with H.235.1 tokens. This is very good practice, but not all vendors implement it.
(AudioCodes and Innovaphone do.)

<item><tt/CheckSendersID=0/<newline>
Default: <tt/1/<newline>
<p>
Check if the SendersID inside tokens matches their alias or endpointID.
This switch replaces the CheckID= switch in the [...PasswordAuth] sections.

<item><tt/VerifyRandomNumber=0/<newline>
Default: <tt/1/<newline>
<p>
Disable the check if the endpoint sends the same random number multiple times for the same timestamp.
Innovaphone r6 - r11 sometimes sends 32bit random numbers with the high bit set that are all decoded
into -1 by H323Plus causing the check to fail. This might be a bug in the PTLib ASN decoder.

<item><tt/TimestampGracePeriod=60/<newline>
Default: <tt/7210/<newline>
<p>
Acceptable difference in timestamps inside H.235.1 tokens between endpoint and gatekeeper in seconds.

The default is 2 hours and 10 seconds to accomodate endpoints
with bad clock settings and in different time zones.

It is suggested that you use NTP to syncronize clocks in all your devices
and tighten this grace period accordingly.

</itemize>

<descrip><tag/Example #1/

A very relaxed H.235 configuration, allowing many variations in vendor implementations.

<tscreen><verb>
[H235]
UseEndpointIdentifier=0
RequireGeneralID=0
FullQ931Checking=0
CheckSendersID=0
VerifyRandomNumber=0
TimestampGracePeriod=7210
</verb></tscreen>
</descrip>

<descrip><tag/Example #2/

A very secure H.235 configuration, checking all aspects as defined by the ITU.

<tscreen><verb>
[H235]
UseEndpointIdentifier=1
RequireGeneralID=1
FullQ931Checking=1
CheckSendersID=1
VerifyRandomNumber=1
TimestampGracePeriod=60
</verb></tscreen>
</descrip>


<sect1>Section &lsqb;SimplePasswordAuth&rsqb;
<label id="password">
<p>
This section defines the userid and password pairs used by
<tt/SimplePasswordAuth/ module. All passwords are encrypted
using the <tt/addpasswd/ utility.

Usage:
<tscreen><verb>
addpasswd config section userid password
</verb></tscreen>

Example:
<tscreen><verb>
addpasswd config.ini SimplePasswordAuth frank secret
</verb></tscreen>

Options:
<itemize>
<item><tt/KeyFilled=123/<newline>
Default: <tt/0/<newline>
<p>
Default value to use as a padding byte during password encryption/decryption.

<item><tt/CheckID=1/<newline>
Default: <tt/0/<newline>
<p>
DEPRECATED: Please use the CheckSendersID= switch in the [H235] section.

Check if the aliases match the ID in the tokens. Some endpoints use separate names
for their alias and for authentication. If all your endpoints use their alias as ID
in the tokens, you can tighten security by checking it.

This switch applies to the RAS tokens of all password authenticators.

<item><tt/PasswordTimeout=120/<newline>
Default: <tt/-1/<newline>
<p>
The module <tt/SimplePasswordAuth/ will cache an
authenticated password. This field defines the cache timeout value in seconds.
<tt/0/ means never cache the password, while a negative value
means the cache never expires.

<item><tt/DisableAlgorithm=MD5,H.235.1,CAT/<newline>
Default: <tt>N/A</tt><newline>
<p>
Disable H.235 authentication algorithms in the GRQ/GCF negotiation, otherwise all algorithms supported by GnuGk are used.
A disabled algorithm will still be used if it is used by an endpoint without negotiation.
This switch can be used to avoid incompatibilities with vendor implementations.

</itemize>


<sect1>Section &lsqb;SQLPasswordAuth&rsqb;
<label id="sqlpasswordauth">
<p>
Authenticate H.235 enabled endpoints using passwords stored
in a SQL database. This section defines the SQL driver to use,
SQL database connection parameters and the query to use to retrieve passwords.

Use the <ref id="database" name="common database configuration options">
to define your database connection for this module.

<itemize>
<item><tt/CacheTimeout=120/<newline>
Default: <tt/-1/<newline>
<p>
This field defines how long (alias;password) pairs retrieved from the database 
will be cached. The cache timeout value is expressed in seconds.
<tt/0/ means to not cache passwords, while a negative value
means the cache never expires (only <tt/reload/ command will refresh the cache).

<item><tt/Query=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Defines SQL query used to retrieve H.235 password from the database. The query
is parameterized - that means parameter replacement is made before each query
is executed. Parameter placeholders are denoted by <bf/%1/, <bf/%2/, ... strings.
Specify %% to embed a percent character before a digit into string (like <bf/%%1/),
specify <bf/%{1}/ to allow expansion inside complex expressions like <bf/%{1}123/.
For <tt/SQLPasswordAuth/ two parameters are defined:
<itemize>
<item><tt/%1/ - the actual alias to query the password for
<item><tt/%2/ - the gatekeeper identifier
</itemize>
<p>
Sample query strings:
<tscreen><verb>
SELECT h235password FROM users WHERE alias = '%1' AND active
SELECT h235password FROM users WHERE alias = '%1' AND gk = '%2'
</verb></tscreen>

</itemize>

<sect1>Section &lsqb;H350PasswordAuth&rsqb;
<label id="h350passwordauth">
<p>
<itemize>
<item><tt/PasswordTimeout=120/<newline>
Default: <tt/-1/<newline>
<p>
The module <tt/SimplePasswordAuth/ will cache an
authenticated password. This field defines the cache timeout value in seconds.
<tt/0/ means never cache the password, while a negative value
means the cache never expires.
</itemize>

<sect1>Section &lsqb;RasSrv::RRQAuth&rsqb;
<label id="rrqauth">
<p>
Specify the action on RRQ reception (confirm or deny) for <tt/AliasAuth/ module.
The first alias (this will mostly be an H323ID) of the endpoint to
register is looked up in this section. If a parameter is found the value will
apply as a rule. A rule consists of conditions separated by "&".
A registration is accepted when all conditions apply.
If an endpoint is using H.460.18, the port in the authentication rule will be ignored.

<descrip>
<tag/Syntax:/
<tscreen><verb>
&lt;authrules&gt; :=  empty  |  &lt;authrule&gt; "&" &lt;authrules&gt;

  &lt;authrule&gt;  := &lt;authtype&gt; ":" &lt;authparams&gt;
  &lt;authtype&gt;  := "sigaddr" | "sigip"
  &lt;autparams&gt; := [!&]*
</verb></tscreen>
</descrip>

The notation and meaning of <tt/&lt;authparams&gt;/ depends on
<tt/&lt;authtype&gt;/:

<itemize>
<item><tt/sigaddr/ - extended regular expression that has to match against the
``PrintOn(ostream)'' representation of the signal address of the request.
<p>
Example:
<tscreen><verb>
sigaddr:.*ipAddress .* ip = .* c0 a8 e2 a5 .*port = 1720.*
</verb></tscreen>

<item><tt/sigip/ - specialized form of `<tt/sigaddr/'.
Write the signaling IP address. If the port is omitted, 1720 is assumed.

<p>
Examples:
<tscreen><verb>
sigip:192.168.242.165:1720
sigip:[2a01:4f8:61:2243::2]:1720
sigip:2a01:4f8:61:2243::2
</verb></tscreen>

<item><tt/allow/ - always accept the alias.

<item><tt/deny/ - always reject the alias.

</itemize>

Example:
<tscreen><verb>
[RasSrv::RRQAuth]
; The endpoint with alias 'cwhuang' must register from 10.0.1.10:1720
cwhuang=sigip:10.0.1.10:1720
; The endpoint with alias 'gw1' must register from 10.0.1.0/24
gw1=sigaddr:.*ipAddress .* ip = .* 0a 00 01 .*port = 1720.*
; The endpoint with alias 'gw2' must register from [2a01:4f8:61:2243::2]:1720
gw2=sigip:[2a01:4f8:61:2243::2]:1720
</verb></tscreen>

<sect1>Section &lsqb;SQLAliasAuth&rsqb;
<label id="sqlaliasauth">
<p>
Authenticate endpoints using rules stored in the SQL database
(the rules conform to the format defined in the <ref id="rrqauth" name="[RasSrv::RRQAuth]"> section). 
This section defines which SQL driver to use, SQL database connection parameters 
and the query to use to retrieve the patterns.

Use the <ref id="database" name="common database configuration options">
to define your database connection for this module.

<itemize>
<item><tt/CacheTimeout=120/<newline>
Default: <tt/0/<newline>
<p>
This field defines how long (alias;authrule) pairs retrieved from the database 
will be cached. The cache timeout value is expressed in seconds.
<tt/0/ means not to cache rules, while a negative value
means the cache never expires (only <tt/reload/ command will refresh the cache).

<item><tt/Query=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Defines the SQL query used to retrieve alias rule from the database. The query
is parameterized - that means parameter replacement is made before each query
is executed. Parameter placeholders are denoted by <bf/%1/, <bf/%2/, ... strings.
Specify %% to embed a percent character before a digit into string (like <bf/%%1/),
specify <bf/%{1}/ to allow expansion inside complex expressions like <bf/%{1}123/.
For <tt/SQLAliasAuth/ two parameters are defined:
<itemize>
<item><tt/%1/ - the actual alias to query the rule for
<item><tt/%2/ - the gatekeeper identifier
</itemize>
<p>
Sample query strings:
<tscreen><verb>
SELECT authrule FROM users WHERE alias = '%1' AND active
SELECT 'sigip:' || host(ip) || port FROM users WHERE alias = '%1'
</verb></tscreen>

</itemize>

<sect1>Section &lsqb;SQLAuth&rsqb;
<label id="sqlauth">
<p>
Authenticate and authorize endpoints/calls using a SQL database.
Support for RRQ, ARQ, LRQ and Setup events is provided.

Use the <ref id="database" name="common database configuration options">
to define your database connection for this module.

<itemize>
<item><tt/RegQuery=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Defines the SQL query to be used to perform authentication and authorization
of endpoint registrations. The query is parameterized - that means parameter
replacement is made before each query is executed. The following parameters are defined:
<itemize>
<item><tt/%g/ - the gatekeeper identifier
<item><tt/%{gkip}/ - a gatekeeper IP the request has been received on
<item><tt/%u/ - username associated with the endpoint (usually a H.323 ID)
<item><tt/%{Calling-Station-Id}/ - E.164 associated with the endpoint
<item><tt/%{callerip}/ - caller's/registrant's IP (where the registration request has been received from - NAT IP for NATed endpoints)
<item><tt/%{aliases}/ - a comma separated list of endpoint aliases
<item><tt/%{additive-rrq}/ - whether it is an additive rrq (0 = false, 1 = true)
</itemize>
<p>
If the query returns no rows, the result is undefined, which basically
means failure for <tt/required/ rules and "try next" for optional rules.
Otherwise, the first result row is examined to determine the result of the authentication
request and to get additional information:
<enum>
<item>The first column is converted into a boolean value (1, T, TRUE, allow, y, yes means true)
      and is an authentication result (accept/reject).
<item>If the registration is successfully authenticated the remaining columns 
      are examined:
<enum>
	<item>If there exists a column called <tt/'aliases'/, replace original endpoint
		aliases with these new ones
	<item>If there exists a column called <tt/'billingmode'/, set a billing mode
		associated with the endpoint (0 - credit, &lt;&gt;0 - debit)
	<item>If there exists a column called <tt/'creditamount'/, set account balance
		associated with the endpoint (this is an arbitrary string)
</enum>
</enum>
<p>
Query string examples:
<tscreen><verb>
SELECT 1, 0 AS billingmode, '12.00 USD' AS creditamount
SELECT NOT disabled, assignaliases AS aliases, balance FROM users WHERE h323id = '%u'
SELECT * FROM get_registration_auth('%g', '%u', '%{callerip}', '%{aliases}') AS result(accept, aliases, billingmode, creditamount)
</verb></tscreen>

<item><tt/NbQuery=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Defines the SQL query to be used to perform authentication and authorization
of location requests sent from neighbors. The query is parameterized - that means parameter
replacement is made before each query is executed. The following parameters are defined:
<itemize>
<item><tt/%g/ - the gatekeeper identifier
<item><tt/%{gkip}/ - a gatekeeper IP the request has been received on
<item><tt/%{nbid/ - neighbor identifier from the config
<item><tt/%{nbip}/ - neighbor IP (where the request has been received from)
<item><tt/%{Calling-Station-Id}/ - caller's number, if available
<item><tt/%{src-info}/ - content of sourceInfo LRQ field, if available
<item><tt/%{Called-Station-Id}/ - destination number
<item><tt/%{dest-info}/ - content of destinationInfo LRQ field
<item><tt/%{bandwidth}/ - requested bandwidth, if present in the LRQ
</itemize>
<p>
If the query returns no rows, the result is undefined, which basically
means failure for <tt/required/ rules and "try next" for optional rules.
Otherwise, the first result row is examined to determine the result of the authentication
and to get additional information:
<enum>
<item>The first column is converted into a boolean value (1, T, TRUE, allow, y, yes means true)
      and is an authentication result (accept/reject).
<item>If the request is authenticated successfully, remaining columns 
      are examined:
<enum>
	<item>If there exists a column called <tt/'destination'/, populate the original
		destinationInfo field with these new aliases - this may affect routing
		decision, which is made after auth step.
</enum>
</enum>
<p>
Query string examples:
<tscreen><verb>
SELECT active FROM neighbors WHERE name = '%{nbid}' AND ip = '%{nbip}' UNION SELECT 0
</verb></tscreen>

<item><tt/CallQuery=SELECT .../<newline>
Default: <tt>N/A</tt><newline>
<p>
Define a SQL query to be used to perform authentication and authorization
of calls (ARQ and Setup). The query is parameterized - that means parameter
replacement is made before each query is executed. The following parameters are defined:
<itemize>
<item><tt/%g/ - the gatekeeper identifier
<item><tt/%{gkip}/ - a gatekeeper IP the request has been received on
<item><tt/%u/ - a username associated with the caller
<item><tt/%{callerip}/ - caller's IP (where the request has been received from - NAT IP for NATed endpoints)
<item><tt/%{Calling-Station-Id}/ - caller's number, if available
<item><tt/%{Called-Station-Id}/ - destination number
<item><tt/%{Dialed-Number}/ - original destination number (before rewrite)
<item><tt/%{CallId}/ - H.323 call identifier (16 hex 8-bit digits)
<item><tt/%{SrcInfo}/ - srcInfo field of the ARQ or sourceAddress from Setup
<item><tt/%{Vendor}/ - productId and versionId
<item><tt/%{bandwidth}/ - requested bandwidth, if present in the ARQ
<item><tt/%{answer}/ - 1, if the request is an answering ARQ
<item><tt/%{arq}/ - 1 for ARQ triggered query, 0 for Setup triggered query
<item><tt/%{from-neighbor}/ - 1 calls from neighbor gatekeeper, 0 for other calls
</itemize>
<p>
If the query returns no rows, the result is undefined, which basically
means failure for <tt/required/ rules and "try next" for optional rules.
Otherwise, the first result row is examined to determine the authentication
result and to get additional information:
<enum>
<item>The first column is converted into a boolean value (1, T, TRUE, allow, y, yes means true)
      and is an authentication result (accept/reject the call).
<item>If the request is authenticated successfully, remaining columns 
      are examined:
<enum>
	<item>If there exists a column called <tt/'billingmode'/, set a billing mode
		associated with the endpoint (0 - credit, &lt;&gt;0 - debit)
	<item>If there exists a column called <tt/'creditamount'/, set account balance
		associated with the endpoint (this is an arbitrary string)
	<item>If there exists a column called <tt/'credittime'/, use its integer
          value to set call duration limit
	<item>If there exists a column called <tt/'redirectnumber'/, replace
          the original destination number with this one. You can put multiple
		  numbers (that correspond to multiple <tt/'redirectip'/ entries) separated
		  by a semicolon. You can also specify an outbound number (to be sent to a terminating gateway)
		  by appending it with an '=' to the rewritten number (like 485811001001=1234485811001001)
	<item>If there exists a column called <tt/'redirectip'/, force the call
          to be sent to the specified IP (one can put multiple destinations
		  separated by a semicolon, that will be used for failover, if failover is activated)
	<item>If there exists a column called <tt/'proxy'/, force the gatekeeper
          to enable/disable (depends on the 'proxy' column value) RTP proxy
          for this call
	<item>If there exists a column called <tt/'clientauthid'/, the gatekeeper will store
          this ID in its call record and send it back on all accounting events.
          This must be an unsigned integer with a maximum of 64 bits (eg. 'bigint unsigned' in MySQL).
</enum>
<item>If the request is denied, the remaining columns are examined:
<enum>
	<item>If there exists a column called <tt/'q931cause'/, set a Q.931 cause in a Release Complete
		  to this value
	<item>If there exists a column called <tt/'clientauthid'/, the gatekeeper will store
          this ID in its call record and send it back on all accounting events.
          This must be an unsigned integer with a maximum of 64 bits (eg. 'bigint unsigned' in MySQL).
</enum>
</enum>
<p>
Query string examples:
<tscreen><verb>
SELECT 1, 360 AS credittime, 0 AS proxy
SELECT * FROM auth_call('%g', '%u', '%{Calling-Station-Id}', '%{callerip}', '%{Called-Station-Id}') AS result(accept, credittime)
SELECT 1, '1234' AS redirectnumber, '192.168.1.1' AS redirectip
</verb></tscreen>

</itemize>


<sect1>Section &lsqb;PrefixAuth&rsqb;
<label id="prefixauth">
<p>
The section defines the authentication rule for the <tt/PrefixAuth/ module.
You can authorized ARQs, LRQs and Setups with this module.

First, the most specific prefix is selected according to the <bf/destinationInfo/
field of the received request. Then the request is accepted or rejected
according to the matched rules with the most specific netmask.
If no matched prefix is found,
and the <tt/default/ option is specified, the request is accepted
or rejected according to that. Otherwise
it is rejected or passed to the next authentication module
according to the module requirement.

<descrip>
<tag/Format:/
<tscreen><verb>
prefix=authrule[|authrule|...]
</verb></tscreen>

<tag/Syntax:/
<tscreen><verb>
&lt;authrule&gt; :=  &lt;result&gt; &lt;authrule&gt;

  &lt;result&gt;    := deny | allow
  &lt;authrule&gt;  := [!]ip:&lt;iprule&gt; | [!]ipv4:&lt;iprule&gt; | [!]ipv6:&lt;iprule&gt; | [!]alias:&lt;aliasrule&gt;
</verb></tscreen>
</descrip>
Where <tt/&lt;iprule&gt;/ can be specified in decimal dot notation or
CIDR notation or IPv6 notation, <tt/&lt;aliasrule&gt;/ is expressed in regular expression.
If the `<tt/!/' flag precedes the rule, the sense is inverted.
Rules for IP numbers with <tt/ip:/, <tt/ipv4:/, <tt/ipv6:/ all behave the same.
The different prefixes are just for documentation and compatibility with older versions of GnuGk.

<descrip>
<tag/Example:/
<tscreen><verb>
555=deny ipv4:10.0.0.0/27|allow ipv4:0/0
5555=allow ipv4:192.168.1.1|deny ipv4:192.168.1.0/255.255.255.0
86=deny !ipv4:172.16.0.0/24
09=deny alias:^188884.*
99=deny ipv6:2021:4ad0:ff00:99a::/64
ALL=allow ipv4:0/0|allow ipv6:::/0
</verb></tscreen>
</descrip>

In this configuration, all endpoints except those from network <tt>10.0.0.0/27</tt>
are allowed to call prefix 555 (except 5555).
Endpoints from <tt>192.168.1.0/24</tt> are not allowed to call prefix 5555,
except <tt/192.168.1.1/.
Endpoints <bf/not/ from <tt>172.16.0.0/24</tt> are denied to call prefix 86.
Endpoints having an alias beginning with 188884 are not allowed to call
prefix 09.
IPv6 endpoints from 2021:4ad0:ff00:99a::/64 are not allowed to call prefix 99.
All other situations are allowed.

<sect1>Section &lsqb;RadAuth&rsqb;
<label id="radauth">
<p>
This section defines configuration settings that enable
RADIUS authentication based on H.235 CATs (Cisco Access Tokens)
present in RRQ, ARQ RAS requests and Q.931 Setup messages.
<itemize>
<item><tt/Servers=SERVER1[:AUTH_PORT[:ACCT_PORT[:SECRET]]];SERVER2[:AUTH_PORT[:ACCT_PORT[:SECRET]]];.../<newline>
Default: <tt>N/A</tt><newline>
<p>
RADIUS servers to be used for authentication. The list can contain an arbitrary 
number of servers. The order of servers is important, because servers will 
be queried by the RADIUS module in the given order. If no port information 
is provided, port number from <tt/DefaultAuthPort/ will be used. If no secret is set, 
the default shared secret from <tt/SharedSecret/ is taken. 
Servers names can be IP addresses or DNS names. IPv6 addresses must always be written in brackets.

<descrip>
<tag>Sample <tt/Servers/ lines:</tag>
<tt>Servers=192.168.1.1</tt><newline>
<tt>Servers=192.168.1.1:1645</tt><newline>
<tt>Servers=192.168.1.1:1645:1646:secret1</tt><newline>
<tt>Servers=radius1.mycompany.com:1812</tt><newline>
<tt>Servers=radius1.mycompany.com;radius2.mycompany.com</tt><newline>
<tt>Servers=radius1.mycompany.com:1812:1813:secret1;radius2.mycompany.com:1812:1813:secret2</tt><newline>
<tt>Servers=[2501:4f3:61:2143::2]</tt><newline>
<tt>Servers=[2501:4f3:61:2143::2]:1645</tt><newline>
<tt>Servers=[2501:4f3:61:2143::2]:1645:1646</tt><newline>
<tt>Servers=[2501:4f3:61:2143::2]:1645:1646:secret1</tt><newline>
<tt>Servers=[2501:4f3:61:2143::2]:1645:1646:secret1;[2501:4f3:61:2143::3]:1645:1646:secret2</tt><newline>
</descrip>

<item><tt/LocalInterface=IP_OR_FQDN/<newline>
Default: <tt>N/A</tt><newline>
<p>
The specific local network interface that GnuGk should
use in order to communicate with RADIUS servers. This parameter
can be useful on NAT machines to restrict which network
interfaces are used for RADIUS communication. By default this value
is empty and allows RADIUS requests to be sent on any (best suitable)
network interface. If you are not sure what you are doing, it is
better to leave this option unset.

<item><tt/RadiusPortRange=10000-11000/<newline>
Default: <tt>N/A</tt><newline>
<p>
By default, GnuGk
allocates ports dynamically as specified by the operating system.
If you want to restrict which ports it should use then configure this parameter.

<item><tt/DefaultAuthPort=PORT_NO/<newline>
Default: <tt>1812</tt><newline>
<p>
Default port number to be used for RADIUS authentication requests
(Access-Request packets).  Can be overridden by <tt/Servers/ attribute.

<item><tt/SharedSecret=SECRET/<newline>
Default: <tt>N/A (empty string)</tt><newline>
<p>
Secret used to authenticate this GnuGk (NAS client) to RADIUS
server. It should be a cryptographically strong password. This is the default
value used if no server-specific secret is set in the <tt/Servers/ configuration option.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in encrypted form and should be created using
the <tt/addpasswd/ utility.

<item><tt/RequestTimeout=TIMEOUT_MS/<newline>
Default: <tt/2000/ (milliseconds)<newline>
<p>
Timeout (milliseconds) for RADIUS server response to a request
sent by GnuGk. If no response is received within this time period,
the next RADIUS server is queried.

<item><tt/IdCacheTimeout=TIMEOUT_MS/<newline>
Default: <tt/9000/ (milliseconds)<newline>
<p>
Timeout (milliseconds) for RADIUS request 8-bit identifiers to be
unique. If the entire 8-bit identifier range is exhausted within this period,
a new client socket (UDP socket) will be allocated by the RADIUS module. Let's
take the example: we have approximately 60 RRQs/sec - after ca. 4 seconds
8-bit identifiers range gets exhausted - new socket allocated - after next
4 seconds the second 8-bit identifiers range gets exhausted - third socket
allocated - after 9th second identifiers from the pool 1 are available again.

In general, if you have too long a timeout then too many resources will be consumed.
If you have too short a timeout, then the RADIUS server may take incoming packets as duplicates
and therefore drop them.

<item><tt/SocketDeleteTimeout=TIMEOUT_MS/<newline>
Default: <tt/60000/ (milliseconds) - 60 s<newline>
<p>
Timeout for unused RADIUS sockets to be closed. It is used
in conjunction with <tt/IdCacheTimeout/ - additional sockets
created during heavy gatekeeper load periods for serving incoming
requests are closed during idle periods.

<item><tt/RequestRetransmissions=NUMBER/<newline>
Default: <tt/2/<newline>
<p>
How many times a single RADIUS request is transmitted to every
configured RADIUS server (if no response is received). 1 means
one transmission attempt and no re-transmission, 2 - single re-transmission, ... . Exact retransmission
method is defined by <tt/RoundRobinServers/ attribute.

<item><tt/RoundRobinServers=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
RADIUS requests retransmission method.
<p>
If set to 1, RADIUS request
is transmitted in the following way (until response is received):
<tscreen><verb>
Server #1 Attempt #1, Server #2 Attempt #1, ..., Server #N Attempt #1
...
Server #1 Attempt #RequestRetransmissions, ..., Server #1 Attempt #RequestRetransmissions
</verb></tscreen>
<p>
If set to 0, the following sequence is preserved:
<tscreen><verb>
Server #1 Attempt #1, ..., Server #1 Attempt #RequestRetransmissions
...
Server #N Attempt #1, ..., Server #N Attempt #RequestRetransmissions
</verb></tscreen>

<item><tt/AppendCiscoAttributes=BOOLEAN/<newline>
Default: <tt/0/<newline>
<p>
If set, Cisco Vendor Specific RADIUS attributes are included
in RADIUS requests (h323-conf-id,h323-call-origin,h323-call-type).

<item><tt/IncludeTerminalAliases=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
If set, Cisco VSA 'h323-ivr-out' attribute is sent with a list of aliases
the endpoint is registering (RRQ.m_terminalAlias). This attribute is provided
in order to provide fine control over the list of aliases the endpoint
is allowed to register with. Format of this attribute is:
<tscreen><verb>
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:" alias [,alias] [;]
Example:
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:helpdesk,support,77771;"
</verb></tscreen>

<item><tt/UseDialedNumber=BOOLEAN/<newline>
Default: <tt/0/<newline>
<p>
Select Called-Station-Id number type between the original one (as dialed
by the user) - <tt/UseDialedNumber=1/ - and the rewritten one - <tt/UseDialedNumber=0/.

</itemize>

<sect2>&lsqb;RadAuth&rsqb; Access-Request Radius Attributes
<p>
For RRQs, the following RADIUS attributes are included within Access-Request packets:
<p>
<itemize>
<item><tt>User-Name</tt><newline>
<p>
		H225_RegistrationRequest.tokens[CAT].m_generalID

<item><tt>CHAP-Password</tt><newline>
<p>
		H225_RegistrationRequest.tokens[CAT].m_random 
		+ H225_RegistrationRequest.tokens[CAT].m_challenge

<item><tt>CHAP-Challenge</tt><newline>
<p>
		H225_RegistrationRequest.tokens[CAT].m_timeStamp

<item><tt>NAS-IP-Address</tt><newline>
<p>
		GnuGk Home or a particular local network interface set
		by 'LocalInterface' config parameter

<item><tt>NAS-Identifier</tt><newline>
<p>
		GnuGk Name

<item><tt>NAS-Port-Type</tt><newline>
<p>
		Virtual (GnuGk does not have concept of physical ports)

<item><tt>Framed-IP-Address</tt><newline>
<p>
		An IP address of registering endpoint signaling channel 

<item><tt>Service-Type</tt><newline>
<p>
		Login-User

<item><tt>(optional) VSA: VendorId=Cisco, Cisco-AVPair, h323-ivr-out</tt><newline>
<p>
		A list of aliases an endpoint is registering with
		(only if IncludeTerminalAliases config option is set)
<p>
NOTE: The list of aliases inside h323-ivr-out is in the following form:<newline>
<tt>h323-ivr-out="h323-ivr-out=terminal-alias:alias1,alias2,...,aliasN;"</tt><newline>
      The h323-ivr-out attribute can be (in future) instantiated multiple times
      inside a single Access-Request and may also contain variables other than
	  "terminal-alias", so a RADIUS server should be flexible enough 
	  with processing of this attribute.
</itemize>
<p>
For ARQ and Setup messages, the following RADIUS attributes are included
inside Access-Request packets:
<p>
<itemize>

<item><tt>User-Name</tt><newline>
<p>
		ARQ.tokens[CAT].m_generalID

<item><tt>CHAP-Password</tt><newline>
<p>
		ARQ.tokens[CAT].m_random + ARQ.tokens[CAT].m_challenge

<item><tt>CHAP-Challenge</tt><newline>
<p>
		ARQ.tokens[CAT].m_timeStamp

<item><tt>NAS-IP-Address</tt><newline>
<p>
		GnuGk Home or a particular local network interface set
		by 'LocalInterface' config parameter

<item><tt>NAS-Identifier</tt><newline>
<p>
		GnuGk Name

<item><tt>NAS-Port-Type</tt><newline>
<p>
		Virtual (GnuGk does not have concept of physical ports)

<item><tt>Framed-IP-Address</tt><newline>
<p>
		An IP address of registering endpoint signaling channel 

<item><tt>Service-Type</tt><newline>
<p>
		Login-User (for ARQs from originating endpoint)
		or Call-Check (for ARQs from answering endpoint)
	
<item><tt>Calling-Station-Id</tt><newline>
<p>
		Calling party's number (if available)
		
<item><tt>Called-Station-Id</tt><newline>
<p>
		Called party's number

<item><tt>(optional) VSA: VendorId=Cisco, h323-conf-id</tt><newline>
<p>
		H.323 conference ID from ARQ
		
<item><tt>(optional) VSA: VendorId=Cisco, h323-call-type</tt><newline>
<p>
		Call type (fixed value: "h323-call-type=VoIP")
		
<item><tt>(optional) VSA: VendorId=Cisco, h323-call-origin</tt><newline>
<p>
		Call origin ("answer","originate")
		
<item><tt>(optional) VSA: VendorId=Cisco, h323-gw-id</tt><newline>
<p>
		The same as NAS-Identifier
</itemize>


<sect2>&lsqb;RadAuth&rsqb; Access-Accept Radius Attributes
<p>
For RRQs, the following RADIUS attributes are recognized 
inside Access-Accept packets:
<p>
<itemize>
<item><tt>VSA: VendorId=Cisco, h323-return-code</tt><newline>
<p>
		If present and not 0, the request is rejected. This check is provided 
		to allow interoperability with some poor billing systems, which send 
		Access-Accept with non-zero h323-return-code to reject the call instead
		of Access-Reject. The attribute can be in the form h323-return-code="1" 
		or h323-return-code="h323-return-code=1". Note that the return code
		is a string, not an integer.

<item><tt>VSA: VendorId=Cisco, h323-billing-model</tt><newline>
<p>
		Billing mode for this account. Can be 0 (credit), 1 or 2 (debit). 
		If an endpoint can understand H.225.0 CallCreditServiceControl messages,
		this information is used to build the message.
		
<item><tt>VSA: VendorId=Cisco, h323-credit-amount</tt><newline>
<p>
		A string representing current user's account balance. If an endpoint 
		can understand H.225.0 CallCreditServiceControl messages, 
		this information is used to build the message.
		
<item><tt>VSA: VendorId=Cisco, Cisco-AVPair, h323-ivr-in</tt><newline>
<p>
		If present, it is scanned for 'terminal-alias' variable that can contain
		a list of aliases that should be assigned to the endpoint being registered.
		All RRQ aliases that do not match this list are removed.
		The 'disable-codec' variable is also supported to disallow certain codecs for this call.
		The 'proxy' variable that can contain 'yes' or 'no' for enabling/disabling proxy mode for this call.
		The format of these attributes is:
<p>
<tt>Cisco-AVPair = "h323-ivr-in=variable:value;[variable:value;]"</tt><newline>
<p>
		where the "variable" can be "terminal-alias":
<p>
			Cisco-AVPair = "h323-ivr-in=terminal-alias:alias1[,alias2,...];"
<p>
<descrip>
<tag/Example 1:/
<tscreen><verb>
RRQ {
	m_terminalAlias = { "myalias", "1234" }
}

if RADIUS server returns the following h323-ivr-in:

Access-Accept {
	Cisco-AVPair = "h323-ivr-in=terminal-alias:anotheralias,6789;"
}

the endpoint will get registered with aliases "anotheralias" and "6789".
Also RCF will contain:

RCF {
	m_terminalAlias = { "anotheralias", "6789" }
}
</verb></tscreen>
</descrip>
		
<descrip>
<tag/Example 2 (add E164 to an existing alias):/
<tscreen><verb>
RRQ {
	m_terminalAlias = { "it_s_me" }
}

if RADIUS server returns the following h323-ivr-in:

Access-Accept {
	Cisco-AVPair = "h323-ivr-in=terminal-alias:it_s_me,48586259732;"
}

RCF will contain:

RCF {
	m_terminalAlias = { "it_s_me", "48586259732" }
}
</verb></tscreen>
</descrip>

<descrip>
<tag/Example 3 (disable G.711 and G.729 codecs):/
<tscreen><verb>
Access-Accept {
	Cisco-AVPair = "h323-ivr-in=codec-disable:g711Ulaw64k;g729;g711Alaw64k;g729AnnexA;"
}
</verb></tscreen>
</descrip>

<descrip>
<tag/Example 4 (enable proxy mode):/
<tscreen><verb>
Access-Accept {
	Cisco-AVPair = "h323-ivr-in=proxy:yes"
}
</verb></tscreen>
</descrip>

</itemize>
<p>	
For ARQs, the following RADIUS attributes are recognized
within Access-Accept packets:
<p>
<itemize>
<item><tt>VSA: VendorId=Cisco, h323-return-code</tt><newline>
<p>
		If present and not 0, the request is rejected. This check is provided
		to allow interoperability with some poor billing systems, that send 
		Access-Accept with non-zero h323-return-code to reject the call instead 
		of Access-Reject. The attribute can be in form h323-return-code="1" 
		or h323-return-code="h323-return-code=1". Note that the return code
		is a string, not an integer.

<item><tt>VSA: VendorId=Cisco, h323-billing-model</tt><newline>
<p>
		Billing mode for this account. Can be 0 (credit), 1 or 2 (debit). 
		If an endpoint can understand H.225.0 CallCreditServiceControl messages,
		this information is used to build the message.
		
<item><tt>VSA: VendorId=Cisco, h323-credit-amount</tt><newline>
<p>
		A string representing current user account balance. If an endpoint can 
		understand H.225.0 CallCreditServiceControl messages, this information 
		is used to build the message.
		
<item><tt>VSA: VendorId=Cisco, h323-credit-time</tt><newline>
<p>
		If present, it enforces maximum call duration (in seconds).
		The attribute can be in form of h323-credit-time="120" 
		or h323-credit-time="h323-credit-time=120". Note that the return code 
		is a string, not an integer.
					   
<item><tt>Session-Timeout</tt><newline>
<p>
		If present, it enforces maximum call duration (in seconds).
		This is a standard RADIUS attribute of integer type.

<item><tt>VSA: VendorId=Cisco, h323-redirect-ip-address</tt><newline>
<p>
		If present, a call is sent to the IP address present in this attribute.
		You can put multiple destinations separated with a semicolon.

<item><tt>VSA: VendorId=Cisco, h323-redirect-number</tt><newline>
<p>
		If present, a called station id is rewritten to this number.
		You can put multiple numbers separated by a semicolon.
		For each number you can also specify an outbound number (that is sent
		to a terminating gateway) by appending it with a '='.
</itemize>
<p>
NOTE: If both Session-Timeout and h323-credit-time are present, the smaller value
is used.
<p>
NOTE: If multiple failover mechanisms are specified, eg. multiple numbers in h323-redirect-number
<bf/and/ multiple IPs in h323-redirect-ip-address, there is no guarantee that the the
first number is used for the first IP and the 2nd number for the 2nd IP.
This will usually the case, but for example when a capacity limit disables one IP,
the association will change.
<p>

<sect1>Section &lsqb;RadAliasAuth&rsqb;
<label id="radaliasauth">
<p>
This section defines configuration settings that enable
RADIUS authentication based on endpoint aliases and/or IP addresses
present in a RRQ RAS, ARQ RAS or Q.931 Setup request.
This authentication scheme is useful both for endpoints registered
at the gatekeeper (ARQ, RRQ) and calls from unregistered endpoints (Setup).

<itemize>
<item><tt/Servers=SERVER1[:AUTH_PORT[:ACCT_PORT[:SECRET]]];SERVER2[:AUTH_PORT[:ACCT_PORT[:SECRET]]];.../<newline>
Default: <tt>N/A</tt><newline>
<p>
RADIUS servers to be used for RAS requests authentication.
This list can contain an arbitrary number of servers. The order of servers 
is important, because servers will be queried by the RADIUS module 
in the given order. If no port information is specified, the port number from 
<tt/DefaultAuthPort/ will be used. If no secret is set, 
the default shared secret from <tt/SharedSecret/ is used.
Servers can be IP addresses or DNS names.

<descrip>
<tag/Example:/
<tt/Servers=192.168.3.1:1645;192.168.3.2:1812:1813:mysecret;radius.mycompany.com/
</descrip>

<item><tt/LocalInterface=IP_OR_FQDN/<newline>
Default: <tt>N/A</tt><newline>
<p>
Specific local network interface that GnuGk should
use in order to communicate with RADIUS servers. This parameter
can be useful on NAT machines to restrict number of network
interfaces used for RADIUS communication. By default this value
is empty and allows RADIUS requests to be sent on any (best suitable)
network interface. If you are not sure what you are doing, it is
better to leave this option unset.

<item><tt/RadiusPortRange=10000-11000/<newline>
Default: <tt>N/A</tt><newline>
<p>
By default (if this option is not set) RADIUS client
allocates ports dynamically as specified by the operating system.
If you want to restrict RADIUS client to use ports from
a particular range only - set this parameter.

<item><tt/DefaultAuthPort=PORT_NO/<newline>
Default: <tt>1812</tt><newline>
<p>
Default port number to be used for RADIUS authentication requests
(Access-Request packets), if not overridden by <tt/Servers/ attribute.

<item><tt/SharedSecret=SECRET/<newline>
Default: <tt>N/A (empty string)</tt><newline>
<p>
Secret used to authenticate this GnuGk (NAS client) to RADIUS
server. It should be a cryptographically strong password. This is the default
value used, if no server-specific secret is set in the <tt/Servers/.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in encrypted form and should be created using
the <tt/addpasswd/ utility.

<item><tt/RequestTimeout=TIMEOUT_MS/<newline>
Default: <tt/2000/ (milliseconds)<newline>
<p>
Timeout (milliseconds) for RADIUS server response to a request
sent by GnuGk. If no response is received within this time period,
next RADIUS server is queried.

<item><tt/IdCacheTimeout=TIMEOUT_MS/<newline>
Default: <tt/9000/ (milliseconds)<newline>
<p>
Timeout (milliseconds) for RADIUS request 8-bit identifiers to be
unique. If all 8-bit identifier range is exhausted within this period,
new client socket (UDP socket) is allocation by RADIUS module. Let's
take the example: we have approximately 60 RRQs/sec - after ca. 4 seconds
8-bit identifiers range gets exhausted - new socket allocated - after next
4 seconds the second 8-bit identifiers range gets exhausted - third socket
allocated - after 9th second identifiers from the pool 1 are available again
- ... . In general, too long timeout - too much resources consumed,
too short timeout - RADIUS server may take incoming packets as duplicated
and therefore drop it.

<item><tt/SocketDeleteTimeout=TIMEOUT_MS/<newline>
Default: <tt/60000/ (milliseconds) - 60 s<newline>
<p>
Timeout for unused RADIUS sockets to be closed. It is used
in conjunction with <tt/IdCacheTimeout/ - additional sockets
created during heavy gatekeeper load periods for serving incoming
requests are closed during idle periods.

<item><tt/RequestRetransmissions=NUMBER/<newline>
Default: <tt/2/<newline>
<p>
How many times a single RADIUS request is transmitted to every
configured RADIUS server (if no response is received). 1 means
no retransmission, 2 - single retransmission, ... . Exact retransmission
method is defined by <tt/RoundRobinServers/ attribute.

<item><tt/RoundRobinServers=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
RADIUS requests retransmission method.
<p>
If set to 1, RADIUS request
is transmitted in the following way (until response is received):
<tscreen><verb>
Server #1 Attempt #1, Server #2 Attempt #1, ..., Server #N Attempt #1
...
Server #1 Attempt #RequestRetransmissions, ..., Server #1 Attempt #RequestRetransmissions
</verb></tscreen>
<p>
If set to 0, the following sequence is preserved:
<tscreen><verb>
Server #1 Attempt #1, ..., Server #1 Attempt #RequestRetransmissions
...
Server #N Attempt #1, ..., Server #N Attempt #RequestRetransmissions
</verb></tscreen>

<item><tt/AppendCiscoAttributes=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
If set, Cisco Vendor Specific RADIUS attributes are included
in RADIUS requests (h323-conf-id,h323-call-origin,h323-call-type).

<item><tt/IncludeTerminalAliases=BOOLEAN/<newline>
Default: <tt/1/<newline>
<p>
If set, Cisco VSA 'h323-ivr-out' attribute is sent with a list of aliases
the endpoint is registering (RRQ.m_terminalAlias). This attribute is provided
in order to provide fine control over the list of aliases the endpoint
is allowed to register with. Format of this attribute is:
<tscreen><verb>
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:" alias [,alias] [;]
Example:
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:helpdesk,support,77771;"
</verb></tscreen>

<item><tt/EmptyUsername/<newline>
Default: <tt>N/A</tt><newline>
<p>
If this parameter is set, the value is used if the call doesn't provide
a username for authentication.

<item><tt/FixedUsername/<newline>
Default: <tt>N/A</tt><newline>
<p>
If this parameter is set, it overwrites a value of User-Name RADIUS attribute
for outgoing RADIUS request. That means every Access-Request will be
authenticated as for user <tt/FixedUsername/.

<item><tt/FixedPassword/<newline>
Default: <tt>N/A</tt><newline>
<p>
If not set, User-Password is a copy of User-Name. For example, if User-Name
is 'john' then User-Password will also be set to 'john'. Setting this
parameter overrides this behavior and User-Password attribute will be
always set to the value of <tt/FixedPassword/.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in encrypted form and should be created using
the <tt/addpasswd/ utility.

<descrip>
<tag/Example 1:/
<tscreen><verb>
(Neither FixedUsername nor FixedPassword set)
</verb></tscreen>
All endpoints will be authenticated using their alias as the username
and the password. That means, for example, endpoint 'EP1' will be authenticated
with the username 'EP1 and the password 'EP1'.
</descrip>

<descrip>
<tag/Example 2:/
<tscreen><verb>
(FixedUsername not set)
FixedPassword=ppp
</verb></tscreen>
All endpoints will be authenticated using their alias and the password 'ppp'.
</descrip>

<descrip>
<tag/Example 3:/
<tscreen><verb>
FixedUsername=ppp
FixedPassword=ppp
</verb></tscreen>
All endpoints will be authenticated using the username 'ppp'
and the password 'ppp'.
</descrip>

<item><tt/UseDialedNumber=BOOLEAN/<newline>
Default: <tt/0/<newline>
<p>
Select Called-Station-Id number type between the original one (as dialed
by the user) - <tt/UseDialedNumber=1/ - and the rewritten one - <tt/UseDialedNumber=0/.

</itemize>

<sect2>&lsqb;RadAliasAuth&rsqb; Access-Request Radius Attributes
<p>
For RRQs, the same attributes as with RadAuth are sent, with an exception
of username/password attributes (CHAP-Password, CHAP-Challenge, User-Name):
<p>
<itemize>
<item><tt>User-Name</tt><newline>
<p>
		Either an endpoint alias from RRQ or a value of FixedUsername 
		config parameter. If no alias is present, an IP address is used

<item><tt>User-Password</tt><newline>
<p>
		Either the same as User-Name or a value of FixedPassword
		config parameter
</itemize>
<p>
For ARQ and Setup messages, the same attributes as with RadAuth are sent,
with an exception of username/password attributes (CHAP-Password, 
CHAP-Challenge, User-Name):
<p>
<itemize>
<item><tt>User-Name</tt><newline>
<p>
		Either an endpoint alias or a value of FixedUsername config parameter

<item><tt>User-Password</tt><newline>
<p>
		Either the same as User-Name or a value of FixedPassword config parameter
</itemize>


<sect2>&lsqb;RadAliasAuth&rsqb; Access-Accept Radius Attributes
<p>
Exactly the same attributes are recognized as with RadAuth module.
<p>

<sect1>Section &lsqb;CapacityControl&rsqb;
<label id="capctrl">
<p>
This section contains a set of rules for controlling inbound call volume
depending on various conditions. In order for this module to work, CapacityControl
authentication and accounting modules have to be enabled like this:
<tscreen><verb>
[Gatekeeper::Auth]
CapacityControl=required;Setup
 
[Gatekeeper::Acct]
CapacityControl=required;start,stop
</verb></tscreen>
<p>
A capacity rule can be matched by a caller's IP, caller's H.323 ID and/or
caller's number (CLI) - in the order specified. In addition, the match can
be narrowed by specifying a called number pattern. This module works by keeping
lists of current call volume for each inbound route (rule) - this is done
by having <tt/CapacityControl/ accounting module configured to add/remove
active calls from matching routes. The <tt/CapacityControl/ authentication module
checks rules and accepts/rejects a call based on current/max call volume
for a matching inbound route.
<p>
<descrip>
<tag/Format for an inbound route rule:/
<tt>[ip:CALLER_IP|h323id:CALLER_H323ID|cli:CALLER_NUMBER]=[CALLED NUMBER REGEX PATTERN] MAX_CAPACITY</tt>
<p>
<tt/ip:/, <tt/h323id:/ and <tt/cli:/ prefixes define rule type. An inbound call
will be matched either by caller's IP, H.323ID or CLI. The optional <tt/CALLED NUMBER REGEX PATTERN/
is a regular expression that the called number should match to apply this rule to.
<tt/MAX_CAPACITY/ is maximum number of active calls for this route.
<p>
The rules are match in the following order:
<itemize>
<item>IP rules
<item>H.323ID rules
<item>CLI rules
</itemize>

The longest match in the first matching category is used.

<tag/Example 1:/
<tscreen><verb>
[CapacityControl]
ip:192.168.1.0/24=30
ip:any=120
</verb></tscreen>
<p>
These rules tell that the 192.168.1.0/24 subnet can send up to 30 concurrent
calls, while all other IPs can send up to 120 concurrent calls.
 
<tag/Example 2:/
<tscreen><verb>
[CapacityControl]
%r1% cli:1001=30
%r2% cli:1001=^48(50|51) 5
</verb></tscreen>
<p>
These rules limit caller with CLI 1001 to send up to 5 calls to 4850/4851
destinations and up to 30 calls to other destinations. %r1% and %r2% are
special constructs to allow having the same <tt/cli:1001/ config key more
than once.
</descrip>


<sect1>Section &lsqb;GkH350::Settings&rsqb;
<label id="h350settings">
<p>
This section defines the LDAP server and standard H.350 directory operating
parameters to be used.

<itemize>
<item><tt/ServerName=127.0.0.1/<newline>
Default: <tt/127.0.0.1/
<p>
The LDAP server IP address.

<item><tt/ServerPort=389/<newline>
Default: <tt/389/
<p>
The LDAP server's TCP port (usually 389).

<item><tt/StartTLS=1/<newline>
Default: <tt/0/
<p>
Use StartTLS to encrypt the LDAP connection.

<item><tt/SearchBaseDN=ou=commObjects,dc=gnugk,dc=org/<newline>
Default: <tt>N/A</tt>
<p>
Entry point into the server's H.350 directory structure.
Searches are only made below this root node.

<item><tt/BindUserDN=cn=admin,dc=gnugk,dc=org/<newline>
Default: <tt>N/A</tt>
<p>
The distinguished name the gatekeeper uses to bind
to the LDAP server. Leave empty if you want to access
the LDAP server anonymously.

<item><tt/BindUserPW=secret/<newline>
Default: <tt>N/A</tt>
<p>
If you specified <tt/BindUserDN/, then specify the corresponding
password to be used for binding here.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in an encrypted form and should be created 
using the <tt/addpasswd/ utility.

<item><tt/BindAuthMode=simple/<newline>
Default: <tt>simple</tt>
<p>
Bind Authentication method choices are <tt/simple,sasl,kerberos/

<item><tt/ServiceControl=1/<newline>
Default: <tt/0/<newline>
<p>
Use RRQ/RCF service control field to advise an endpoint of the H.350 directory 
and searchDN to use for white page lookups.

<item><tt/AssignedAliases=1/<newline>
Default: <tt/0/<newline>
<p>
Use H.350.1 to advise endpoints of their assigned aliases.

<item><tt/GatekeeperDiscovery=1/<newline>
Default: <tt/0/<newline>
<p>
Use H.350.1 to resolve on GRQ/GCF the registering endpoints assigned gatekeeper 
(h323IdentityGKDomain).

</itemize>

<sect1>Section &lsqb;GkLDAP::Settings&rsqb;
<label id="ldapsettings">
<p>
This section defines the LDAP server and connection parameters for the LDAP authentication
modules (LDAPAliasAuth and LDAPPasswordAuth) and the LDAP routing policy ('ldap').

<itemize>
<item><tt/ServerName=127.0.0.1/<newline>
Default: <tt/127.0.0.1/
<p>
The LDAP server IP address.

<item><tt/ServerPort=389/<newline>
Default: <tt/389/
<p>
The LDAP server's TCP port (usually 389).

<item><tt/StartTLS=1/<newline>
Default: <tt/0/
<p>
Use StartTLS to encrypt the LDAP connection.

<item><tt/SearchBaseDN=ou=commObjects,dc=gnugk,dc=org/<newline>
Default: <tt>N/A</tt>
<p>
Entry point into the server's directory structure.
Searches are only made below this root node.

<item><tt/BindUserDN=cn=admin,dc=gnugk,dc=org/<newline>
Default: <tt>N/A</tt>
<p>
The distinguished name the gatekeeper uses to bind
to the LDAP server. Leave empty if you want to access
the LDAP server anonymously.

<item><tt/BindUserPW=secret/<newline>
Default: <tt>N/A</tt>
<p>
If you specified <tt/BindUserDN/, then specify the corresponding
password to be used for binding here.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in an encrypted form and should be created 
using the <tt/addpasswd/ utility.

<item><tt/BindAuthMode=simple/<newline>
Default: <tt>simple</tt>
<p>
Bind Authentication method choices are <tt/simple,sasl,kerberos/

</itemize>

<descrip>
<tag/Example:/
<tscreen><verb>
[GkLDAP::Settings]
ServerName=192.168.1.1
BindAuthMode=simple
SearchBaseDN=dc=gnugk,dc=org
BindUserDN=cn=admin,dc=gnugk,dc=org
BindUserPW=secret
</verb></tscreen>
</descrip>


<sect1>Section &lsqb;GkLDAP::LDAPAttributes&rsqb;
<label id="ldapattributes">
<p>
With this section you can map the LDAP attributes GnuGk queries to your LDAP schema.

<itemize>
<item><tt/CallDestination=H323IP/<newline>
Default: <tt/voIPIpAddress/
<p>
The IP where calls for the LDAP entity should be routed.

<item><tt/H323ID=mail/<newline>
Default: <tt/mail/
<p>
The H.323 alias for the LDAP entity. This attribute is used to find the called entity in the LDAP schema.

<item><tt/H235PassWord=secret/<newline>
Default: <tt/none/
<p>
The password attribute to use in LDAPPasswordAuth.

<item><tt/IPAddress=voIPIpAddress/<newline>
Default: <tt/voIPIpAddress/
<p>
The H.323 IP for the LDAP entity. This attribute is used to find the called entity in the LDAP schema.

<item><tt/TelephoneNo=telephoneNumber/<newline>
Default: <tt/telephoneNumber/
<p>
The phone number for the LDAP entity. This attribute is used to find the called entity in the LDAP schema.

</itemize>

<descrip>
<tag/Example:/
<tscreen><verb>
[GkLDAP::LDAPAttributeNames]
IPAddress=voIPIpAddress
H235PassWord=plaintextPassword
H323ID=sn
TelephonNo=telephoneNumber
CallDestination=roomNumber
</verb></tscreen>
</descrip>

<sect1>Section &lsqb;LuaAuth&rsqb;
<label id="luaauth">
<p>
This section configures the scripts for LUA authentication.
<p>
For general information on LUA scripting in GnuGk, please see the chapter <ref id="luascripting" name="LUA Scripting">.
<p>
<itemize>
<item><tt/RegistrationScript=<em>script</em>/<newline>
Default: <tt>N/A</tt>
<p>
LUA script to be used for RRQs. Short scripts can be put directly into the config file. For longer scripts use RegistrationScriptFile=.

<item><tt>RegistrationScriptFile=/path/to/script</tt><newline>
Default: <tt>N/A</tt>
<p>
LUA script to be used for RRQs.

<item><tt/CallScript=<em>script</em>/<newline>
Default: <tt>N/A</tt>
<p>
LUA script to be used for ARQs and Setups.
Short scripts can be put directly into the config file. For longer scripts use CallScriptFile=.

<item><tt>CallScriptFile=/path/to/script</tt><newline>
Default: <tt>N/A</tt>
<p>
LUA script to be used for ARQs and Setups.
</itemize>

Registration authentication scripts can use the following variables
<itemize>
<item><tt/username/ - a username associated with the caller
<item><tt/callingStationId/ - caller's number, if available
<item><tt/callerIP/ - caller's IP (the request has been received from - NAT IP for NATed endpoints)
<item><tt/aliases/ - the list of aliases in the registration
<item><tt/messageType/ - always "RRQ" for registrations
<item><tt/message/ - the full RRQ message as multi-line text block
</itemize>

Call authentication scripts can use the following variables
<itemize>
<item><tt/messageType/ - either "ARQ" or "Setup"
<item><tt/message/ - the full ARQ or Setup message as multi-line text block
<item><tt/source/ - signaling IP of the calling endpoint
<item><tt/calledAlias/ - the called alias
<item><tt/calledIP/ - the called IP
<item><tt/callingStationId/ - caller's number, if available
<item><tt/caller/ - srcInfo of calling endpoint from ARQ or callingStationId from Setup
<item><tt/callid/ - the call ID
<item><tt/srcInfo/ - srcInfo field of the ARQ or sourceAddress from Setup
<item><tt/vendor/ - productId and versionId
</itemize>

The scripts have to store the authentication result in the variable <em>result</em>.
Possible values are "OK", "FAIL" and "NEXT"; everything else will be treated as "FAIL".
<descrip>
<tag/Example:/
<tscreen><verb>
[LuaAuth]
; only let use "boss" register
RegistrationScript=if (username == "boss") then result = "OK" else result = "FAIL" end
; call authentication is in a script file
CallScriptFile=/path/to/callauth.lua
</verb></tscreen>
</descrip>

<sect1>Section &lsqb;LuaPasswordAuth&rsqb;
<label id="luapasswordauth">
<p>
This section configures the script for LUA password authentication.
<p>
For general information on LUA scripting in GnuGk, please see the chapter <ref id="luascripting" name="LUA Scripting">.
<p>
<itemize>
<item><tt/Script=<em>script</em>/<newline>
Default: <tt>N/A</tt>
<p>
LUA script to be used to lookup the password for a user. Short scripts can be put directly into the config file. For longer scripts use ScriptFile=.

<item><tt>ScriptFile=/path/to/script</tt><newline>
LUA script to be used to lookup the password for a user.

<item><tt/PasswordTimeout=120/<newline>
Default: <tt/-1/<newline>
<p>
This module will cache requested passwords. This field defines the cache timeout value in seconds.
<tt/0/ means never cache the password, while a negative value means the cache never expires.

</itemize>

The script can use the following variables
<itemize>
<item><tt/alias/ - the alias of the user to be authenticated
<item><tt/gk/ - the name of the gatekeeper running
</itemize>

The script must store the password for the user in <tt>alias</tt> into the <tt>password</tt> variable
for GnuGk to process further.


<sect1>Section &lsqb;HttpPasswordAuth&rsqb;
<label id="httppasswordauth">
<p>
This section defines fow to fetch password information from an HTTP server.
<p>
<itemize>
<item><tt>URL=http://example.com/passwords</tt><newline>
Default: <tt>N/A</tt>
<p>
The URL to fetch the passwords from. You can use the paremeters specified below to parameterize the URL.
Currently GnuGk expects the cleartext password in the response.

<item><tt/Body=user=%u/<newline>
Default: <tt>empty</tt>
<p>
The HTTP body to use with POST requests. You can use the paremeters specified below to parameterize the URL.

<item><tt/Method=GET/<newline>
Default: <tt>N/A</tt>
<p>
HTTP method to use. Currently GET and POST are supported.

<item><tt/ResultRegex=[0-9]+/<newline>
Default: <tt>.</tt>
<p>
The regular expression to extract the password from the HTTP response.

<item><tt/DeleteRegex=5544/<newline>
Default: <tt>N/A</tt>
<p>
A regular expression to use remove additional patterns from the extracted password. Optional.

<item><tt/ErrorRegex=error/<newline>
Default: <tt>^$</tt>
<p>
If the HTTP response matches this regular expression it is considered invalid.

<item><tt/PasswordTimeout=120/<newline>
Default: <tt/-1/<newline>
<p>
This module will cache requested passwords. This field defines the cache timeout value in seconds.
<tt/0/ means never cache the password, while a negative value means the cache never expires.

</itemize>

For <tt/HttpPasswordAuth/ two parameters are defined:
<itemize>
<item><tt/%u/ - the actual alias to query the password for
<item><tt/%g/ - the gatekeeper identifier (name)
<item><tt/%{message}/ - message that caused this authentication process (eg. RRQ, ARQ etc.)
<item><tt/%{caller-ip}/ - IP of the calling party
<item><tt/%{called-ip}/ - IP of the interface GnuGk received this call on (only available for RAS messages)
<item><tt/%{caller-vendor}/ - product name and version of the caller (only available RRQ and Setup)
<item><tt/%{caller-product-name}/ - product name of the caller (only available RRQ and Setup)
<item><tt/%{caller-product-version}/ - product version of the caller (only available RRQ and Setup)
<item><tt/%{env1}/ - content of environment variable GNUGK_ENV1
<item><tt/.../
<item><tt/%{env9}/ - content of environment variable GNUGK_ENV9
</itemize>

<sect1>Section &lsqb;GeoIPAuth&rsqb;
<label id="geoipauth">
<p>
This section configure the GeoIP authentication.
<p>
<itemize>
<item><tt>Database=/path/to/GeoIP.dat</tt><newline>
Default: <tt>N/A</tt>
<p>
Path to the Maxmind GeoIP database. You can download the latest copy of the GeoIP database from
<htmlurl url="https://dev.maxmind.com/geoip/legacy/geolite/" Name="https://dev.maxmind.com/geoip/legacy/geolite/">

<item><tt>AllowedCountries=US,CA,PRIVATE</tt><newline>
Default: <tt>N/A</tt>
<p>
Define which countries you want to accept messages from. The special country 'PRIVATE' denotes private IPs.
</itemize>

<sect1>Section &lsqb;TwoAliasAuth&rsqb;
<label id="twoaliasauth">
<p>
This section configure the TwoAlias authentication. It contains a list of aliases
with a second ("secret") alias that needs to be present.
Endpoints are accepted if they have a matching pair of aliases.
<p>
Please not that all this information is transmitted as clear text and can be easily intercepted
by packet capturing. This is an extremly weak form of authentication.
<p>
Also note that the sourceAddress field in Setup messages is optional, and many endpoints do not
send it when they are not registered witha gatekeeper and thus fail authentication even if they have matching aliases.

<descrip>
<tag/Example:/
<tscreen><verb>
[TwoAliasAuth]
100=SecretA
101=MoreSecretB
102=WhateverSecretC
</verb></tscreen>
</descrip>

